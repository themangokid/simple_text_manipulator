<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Text Manager Pro - Combine Regex</title>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
  />
  <style>
    /*************************************************
     *                THEME & GLOBAL
     *************************************************/
    :root {
      --primary: #2196f3;
      --background: #ffffff;
      --text: #333;
      --lightGrey: #f0f0f0;
      --danger: #f44336;
      --accent: #4caf50;
    }
    [data-theme="dark"] {
      --background: #2d2d2d;
      --text: #fff;
      --lightGrey: #444;
    }
    body {
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
      background: var(--background);
      color: var(--text);
      transition: background 0.3s, color 0.3s;
    }
    button {
      background: var(--primary);
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      opacity: 0.9;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Minimal tooltip on hover */
    [data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      background: #333;
      color: #fff;
      padding: 5px 8px;
      font-size: 0.8rem;
      border-radius: 4px;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      pointer-events: none;
      z-index: 999;
    }

    /* Notification & Theme Toggle */
    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: none;
      font-size: 1.2rem;
    }
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--primary);
      color: #fff;
      padding: 6px 12px;
      border-radius: 4px;
      display: none;
      z-index: 999;
    }

    /* Grid Layout */
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      max-width: 80%;
      margin: 0 auto;
    }
    @media (max-width: 800px) {
      .container {
        grid-template-columns: 1fr;
      }
    }

    /* Section Styles */
    .section {
      background: var(--lightGrey);
      padding: 10px;
      border-radius: 6px;
    }
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .section-body {
      margin-top: 10px;
    }
    .collapsed .section-body {
      display: none;
    }

    /* Editor Section */
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }
    .text-editor {
      width: 100%;
      height: 200px;
      margin-bottom: 10px;
    }
    #counterPanel {
      font-size: 0.9rem;
      color: #555;
    }

    /* Clipboard Section */
    .search-bar {
      width: 100%;
      margin-bottom: 10px;
    }
    .clipboard-panel {
      max-height: 50%;
      overflow-y: auto;
      display: grid;
      gap: 7px;
    }
    .clip-item {
      background: rgba(0,0,0,0.05);
      padding: 6px;
      border-radius: 4px;
      position: relative;
      display: flex;
      align-items: center;
    }
    .clip-content {
      flex: 1;
      margin-right: 6px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: pointer;
    }
    .type-indicator {
      width: 4px;
      background: var(--primary);
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      border-radius: 4px 0 0 4px;
    }
    #undoButton:disabled {
      background: #666;
    }

    /* Regex Preset CheckList (combining multiple) */
    .checkbox-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
      align-items: center;
    }
    .checkbox-container label {
      display: flex;
      align-items: center;
      gap: 5px;
      background: var(--lightGrey);
      padding: 3px 6px;
      border-radius: 4px;
      cursor: pointer;
    }
    .checkbox-container input[type="checkbox"] {
      cursor: pointer;
    }
    .checkbox-container .combine-button {
      margin-left: auto;
    }

    /* Modal for Preset Management */
    .modal-backdrop {
      display: none;
      position: fixed;
      left: 0; top: 0;
      width: 100vw; height: 100vh;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal {
      background: var(--background);
      color: var(--text);
      padding: 20px;
      border-radius: 10px;
      width: 400px;
      max-width: 90%;
      position: relative;
    }
    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
    }
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    .preset-settings {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      max-height: 60vh;
      overflow-y: auto;
      padding: 10px;
    }
    .preset-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      border-radius: 4px;
      background: var(--lightGrey);
    }
  </style>
</head>
<body>
  <!-- THEME TOGGLE -->
  <button class="theme-toggle" onclick="toggleTheme()" data-tooltip="Toggle Dark/Light Theme">ðŸŒ“</button>

  <!-- NOTIFICATION -->
  <div class="notification" id="notification">Copied!</div>

  <!-- MAIN CONTAINER -->
  <div class="container">

    <!-- EDITOR SECTION -->
    <div class="section" id="editorSection">
      <div class="section-header">
        <h2>Smart Editor <i class="fas fa-edit"></i></h2>
        <button onclick="toggleCollapse('editorSection')"><i class="fas fa-chevron-up"></i></button>
      </div>
      <div class="section-body">
        <!-- Toolbar -->
        <div class="toolbar">
          <button onclick="formatText('bold')" data-tooltip="Wrap selection in ** for bold"><i class="fas fa-bold"></i></button>
          <button onclick="formatText('italic')" data-tooltip="Wrap selection in * for italic"><i class="fas fa-italic"></i></button>
          <button onclick="extractLinks()" data-tooltip="Extract links from editor text"><i class="fas fa-link"></i> Links</button>
          <button onclick="extractEmails()" data-tooltip="Extract emails from editor text"><i class="fas fa-envelope"></i> Emails</button>
        </div>

        <!-- Text Editor -->
        <textarea class="text-editor" id="editor" oninput="updateWordCharCount()"></textarea>

        <!-- Secondary Toolbar -->
        <div class="toolbar">
          <button onclick="processText()" data-tooltip="Detect & add snippet"><i class="fas fa-magic"></i> Process</button>
          <input type="text" id="customRegex" placeholder="Custom Regex (e.g. \\b\\w{5}\\b)" />
          <button onclick="extractCustomRegex()" data-tooltip="Extract with custom regex"><i class="fas fa-search"></i> Extract</button>
        </div>

        <!-- Word/Char Counters -->
        <div id="counterPanel">Words: 0 | Characters: 0</div>

        <!-- Regex Presets as Checkboxes + Combine Button -->
        <div class="checkbox-container" id="presetCheckList">
          <!-- Dynamically populated with checkboxes for currently enabled presets -->
          <!-- "Combine & Extract" button at the end -->
        </div>
      </div>
    </div>

    <!-- CLIPBOARD SECTION -->
    <div class="section" id="clipboardSection">
      <div class="section-header">
        <h2>Clipboard History <i class="fas fa-history"></i></h2>
        <button onclick="toggleCollapse('clipboardSection')"><i class="fas fa-chevron-up"></i></button>
      </div>
      <div class="section-body">

        <!-- Toolbar: Import/Export/Undo & Copy All -->
        <div class="toolbar">
          <button onclick="exportClips()" data-tooltip="Export all clips to JSON"><i class="fas fa-file-export"></i> Export</button>
          <button onclick="importClips()" data-tooltip="Import clips from JSON"><i class="fas fa-file-import"></i> Import</button>
          <button onclick="clearAllClips()" data-tooltip="Delete all snippets"><i class="fas fa-trash"></i> Clear All</button>
          <button id="undoButton" onclick="undoLastAction()" disabled data-tooltip="Undo last action (Ctrl+Z)">
            <i class="fas fa-undo"></i> Undo
          </button>
          <button style="background:#4caf50;" onclick="copyAllClips()" data-tooltip="Copy all clips">
            <i class="fas fa-copy"></i> Copy All
          </button>
          <!-- "Manage Presets" to open the modal -->
          <button onclick="openPresetSettings()" data-tooltip="Manage which presets appear as checkboxes"><i class="fas fa-cog"></i> Manage Presets</button>
          <input type="file" id="fileInput" style="display:none" />
        </div>

        <!-- Search -->
        <input
          type="text"
          class="search-bar"
          placeholder="Search clips..."
          oninput="filterClips(this.value)"
        />

        <!-- Clipboard Panel -->
        <div class="clipboard-panel" id="clipboardPanel"></div>
      </div>
    </div>
  </div>

  <!-- PRESET SETTINGS MODAL -->
  <div class="modal-backdrop" id="presetSettingsModal">
    <div class="modal">
      <button class="close-btn" onclick="closePresetSettings()">&times;</button>
      <h3>Regex Preset Settings</h3>
      <div class="preset-settings" id="presetSettings"></div>
      <div class="modal-footer">
        <button onclick="savePresetSettings()">Save</button>
      </div>
    </div>
  </div>

  <script>
    /*************************************************
     *           GLOBAL VARIABLES & THEME
     *************************************************/
    let clips = JSON.parse(localStorage.getItem("clips") || "[]");
    let currentTheme = localStorage.getItem("theme") || "light";
    document.documentElement.setAttribute("data-theme", currentTheme);

    let actionHistory = [];
    const MAX_HISTORY = 50;

    /*************************************************
     *   FULL, UNMODIFIED REGEX PRESETS (DO NOT DELETE)
     *************************************************/
    const regexPresets = {
      /* ========================
       *  EXISTING PRESETS
       *  (DO NOT DELETE ANY)
       * ======================= */
      sentences: {
        name: "Proper Sentences",
        pattern: /[A-Z][^.!?]*[.!?]/g,
        desc: "Complete sentences starting with capital letter and ending with punctuation",
        enabled: true
      },
      dates: {
        name: "Date Finder",
        pattern: /\b\d{1,2}[\/-]\d{1,2}[\/-]\d{2,4}\b/g,
        desc: "Common date formats (MM/DD/YYYY or DD-MM-YY)",
        enabled: true
      },
      phones: {
        name: "Phone Numbers",
        pattern: /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g,
        desc: "US phone numbers (xxx-xxx-xxxx)",
        enabled: true
      },
      hashtags: {
        name: "Hashtags",
        pattern: /#\w+/g,
        desc: "Social media hashtags",
        enabled: true
      },
      capitalized: {
        name: "Capitalized Words",
        pattern: /\b[A-Z][a-z]+\b/g,
        desc: "Proper nouns and capitalized words",
        enabled: true
      },
      emails: {
        name: "Email Addresses",
        pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
        desc: "Email addresses",
        enabled: false
      },
      urls: {
        name: "URLs",
        pattern: /https?:\/\/[^\s]+/g,
        desc: "Web URLs and links",
        enabled: false
      },
      ipv4: {
        name: "IPv4 Addresses",
        pattern: /\b(?:\d{1,3}\.){3}\d{1,3}\b/g,
        desc: "IPv4 addresses",
        enabled: false
      },
      creditcards: {
        name: "Credit Cards",
        pattern: /\b(?:\d{4}[- ]?){3}\d{4}\b/g,
        desc: "Credit card numbers",
        enabled: false
      },
      htmltags: {
        name: "HTML Tags",
        pattern: /<\/?[a-z][a-z0-9]*\b[^>]*>/gi,
        desc: "HTML tags and elements",
        enabled: false
      },
      uuids: {
        name: "UUIDs",
        pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi,
        desc: "Universally Unique Identifiers",
        enabled: false
      },
      hexcolors: {
        name: "Hex Colors",
        pattern: /#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})\b/g,
        desc: "Hexadecimal color codes",
        enabled: false
      },
      macaddress: {
        name: "MAC Addresses",
        pattern: /\b([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})\b/g,
        desc: "Network device MAC addresses",
        enabled: false
      },
      twitter: {
        name: "Twitter Handles",
        pattern: /@\w+/g,
        desc: "Twitter/X username mentions",
        enabled: false
      },
      bitcoin: {
        name: "Bitcoin Addresses",
        pattern: /\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b/g,
        desc: "Bitcoin wallet addresses",
        enabled: false
      },
      markdownlinks: {
        name: "Markdown Links",
        pattern: /\[.*?\]\(.*?\)/g,
        desc: "Markdown formatted links",
        enabled: false
      },
      jsonkeys: {
        name: "JSON Keys",
        pattern: /"([^"]+)":/g,
        desc: "JSON object keys",
        enabled: false
      },
      cssprops: {
        name: "CSS Properties",
        pattern: /([\w-]+)\s*:/g,
        desc: "CSS properties and values",
        enabled: false
      },
      docker: {
        name: "Docker Commands",
        pattern: /(FROM|RUN|CMD|LABEL|COPY|ADD|ENTRYPOINT)\s+/gi,
        desc: "Common Docker commands",
        enabled: false
      },
      lorem: {
        name: "Lorem Ipsum",
        pattern: /\blorem\s+ipsum\b/gi,
        desc: "Lorem ipsum placeholder text",
        enabled: false
      },
      times: {
        name: "Time Formats",
        pattern: /\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9](?::[0-5][0-9])?\b/g,
        desc: "24-hour time formats (HH:MM:SS)",
        enabled: false
      },
      currency: {
        name: "Currency Values",
        pattern: /\$\d+(?:,\d{3})*(?:\.\d{2})?|\d+(?:,\d{3})*(?:\.\d{2})?(?:USD|EUR|GBP)/gi,
        desc: "Currency amounts and symbols",
        enabled: false
      },

      /* ========================
       *  NEW UNIQUE PRESETS
       *  (SIMPLE & USEFUL)
       * ======================= */
      commalists: {
        name: "Comma-Separated Lists",
        pattern: /\b[A-Za-z]+(?:\s*,\s*[A-Za-z]+)+[,.!;:]*/g,
        desc: "Detects simple lists like 'car, bus, train,' etc.",
        enabled: false
      },
      paragraphs: {
        name: "Paragraphs",
        pattern: /(^|\n)([^\n]+)(?=\n|$)/g,
        desc: "Captures blocks of text separated by line breaks",
        enabled: false
      },
      repeatedwords: {
        name: "Repeated Words",
        pattern: /\b([A-Za-z]+)\s+\1\b/gi,
        desc: "Finds consecutive repeated words (e.g. 'very very')",
        enabled: false
      },
      bulletpoints: {
        name: "Bulleted Lists",
        pattern: /(^|\n)[*+\-]\s+.*/g,
        desc: "Lines beginning with '*', '+' or '-' to denote bullets",
        enabled: false
      },
      bracketed: {
        name: "Bracketed Text",
        pattern: /\([^)]*\)|\[[^\]]*\]|\{[^}]*\}/g,
        desc: "Text enclosed in parentheses, brackets, or braces",
        enabled: false
      },
      lineswithxyz: {
        name: "Lines Containing 'xyz'",
        pattern: /^.*xyz.*$/gim,
        desc: "Matches lines with 'xyz' (case-insensitive)",
        enabled: false
      },
      numericlines: {
        name: "Fully Numeric Lines",
        pattern: /^[0-9\s]+$/gm,
        desc: "Lines made up of digits/spaces only",
        enabled: false
      },
      uppercaseonly: {
        name: "Fully Uppercase Lines",
        pattern: /^[^a-z]*$/gm,
        desc: "Lines without any lowercase letters",
        enabled: false
      },
      singledigitwords: {
        name: "Single-Digit Words",
        pattern: /\b\d\b/g,
        desc: "Isolated single-digit words (0-9)",
        enabled: false
      }
    };

    // Additional detection references
    const textTypes = {
      link: regexPresets.urls,
      code: { pattern: /(`{1,3}[^`]+`{1,3})/g },
      email: regexPresets.emails
    };

    // User's saved preset settings
    let presetSettings = JSON.parse(localStorage.getItem('presetSettings') || '{}');

    /*************************************************
     *               ON LOAD SETUP
     *************************************************/
    window.onload = () => {
      initPresetSettings();
      renderPresetCheckboxes(); // The checkboxes for combined extraction
      renderClips();
      updateUndoButton();
      updateWordCharCount();
    };

    function initPresetSettings() {
      // Merge default 'enabled' states with any saved prefs
      Object.entries(regexPresets).forEach(([id, preset]) => {
        if (!presetSettings.hasOwnProperty(id)) {
          presetSettings[id] = preset.enabled;
        }
      });
      localStorage.setItem('presetSettings', JSON.stringify(presetSettings));
    }

    /*************************************************
     *    CHECKBOX RENDERING & COMBINED EXTRACTION
     *************************************************/
    function renderPresetCheckboxes() {
      const container = document.getElementById('presetCheckList');
      // Only show checkboxes for "enabled" presets
      const enabledEntries = Object.entries(regexPresets).filter(([id]) => presetSettings[id]);

      let checkboxesHtml = '';
      enabledEntries.forEach(([id, preset]) => {
        checkboxesHtml += `
          <label>
            <input type="checkbox" class="presetBox" value="${id}" />
            ${preset.name}
          </label>
        `;
      });

      // Add a "Combine & Extract" button at the end
      checkboxesHtml += `
        <button class="combine-button" onclick="applySelectedPresets()">
          <i class="fas fa-search"></i> Combine & Extract
        </button>
      `;
      container.innerHTML = checkboxesHtml;
    }

    // Called when user clicks "Combine & Extract"
    function applySelectedPresets() {
      const checkedBoxes = document.querySelectorAll('.presetBox:checked');
      if(!checkedBoxes.length) {
        showNotification("No presets selected.");
        return;
      }

      // Combine multiple patterns into a single OR pattern
      const unionParts = [];
      checkedBoxes.forEach(box => {
        const presetId = box.value;
        const source = regexPresets[presetId].pattern.source; // raw regex pattern
        unionParts.push(`(${source})`);
      });
      const combinedPattern = new RegExp(unionParts.join('|'), 'g');

      // Extract from the editor text
      const text = document.getElementById('editor').value;
      const matches = [...text.matchAll(combinedPattern)].map(m => m[0]);

      if(matches.length > 0) {
        matches.forEach(match => addClip(match, 'regex'));
        showNotification(`Found ${matches.length} matches with combined presets!`);
      } else {
        showNotification("No matches found for combined presets.");
      }
    }

    /*************************************************
     *               UNDO SYSTEM
     *************************************************/
    function trackAction(type, data) {
      actionHistory.push({ type, data, timestamp: Date.now() });
      if(actionHistory.length > MAX_HISTORY) actionHistory.shift();
      updateUndoButton();
    }
    function undoLastAction() {
      if(actionHistory.length === 0) return;
      const lastAction = actionHistory.pop();
      switch(lastAction.type) {
        case 'add':
          // Remove clip with matching timestamp
          clips = clips.filter(c => c.timestamp !== lastAction.data.timestamp);
          break;
        case 'delete':
          // Re-insert the deleted clip
          clips.splice(lastAction.data.index, 0, lastAction.data.clip);
          break;
        case 'edit':
          // Revert to old content & tags
          const clip = clips[lastAction.data.index];
          clip.content = lastAction.data.previousContent;
          clip.tags = lastAction.data.previousTags;
          break;
      }
      saveClips();
      renderClips();
      updateUndoButton();
      showNotification(`Undo: ${lastAction.type} action`);
    }
    function updateUndoButton() {
      document.getElementById('undoButton').disabled = (actionHistory.length === 0);
    }

    /*************************************************
     *        EDITOR & TEXT PROCESSING
     *************************************************/
    function processText() {
      const text = document.getElementById("editor").value.trim();
      if(!text) return;
      const detected = detectContent(text);
      addClip(detected.content, detected.type);
    }
    function detectContent(text) {
      if(textTypes.link && textTypes.link.pattern.test(text)) {
        return { type: 'link', content: text };
      } else if(textTypes.email && textTypes.email.pattern.test(text)) {
        return { type: 'email', content: text };
      } else if(textTypes.code && textTypes.code.pattern.test(text)) {
        return { type: 'code', content: text };
      }
      return { type: 'text', content: text };
    }
    function formatText(style) {
      const editor = document.getElementById("editor");
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      const selected = editor.value.slice(start, end);
      let wrapped = selected;
      if(style === "bold") wrapped = `**${selected}**`;
      if(style === "italic") wrapped = `*${selected}*`;
      editor.setRangeText(wrapped, start, end, "end");
      updateWordCharCount();
    }
    function extractLinks() {
      const text = document.getElementById("editor").value;
      const matchArray = text.matchAll(regexPresets.urls.pattern);
      for(const match of matchArray) addClip(match[0], "link");
    }
    function extractEmails() {
      const text = document.getElementById("editor").value;
      const matchArray = text.matchAll(regexPresets.emails.pattern);
      for(const match of matchArray) addClip(match[0], "email");
    }
    function extractCustomRegex() {
      const text = document.getElementById("editor").value;
      const regexString = document.getElementById("customRegex").value;
      if(!regexString) return;
      try {
        const customRegex = new RegExp(regexString, "g");
        const matches = [...text.matchAll(customRegex)].map(m => m[0]);
        matches.forEach(m => addClip(m, "custom"));
      } catch(err) {
        alert("Invalid Regular Expression.");
      }
    }
    function updateWordCharCount() {
      const text = document.getElementById("editor").value;
      const words = text.trim().split(/\s+/).filter(Boolean).length;
      const chars = text.length;
      document.getElementById("counterPanel").textContent = `Words: ${words} | Characters: ${chars}`;
    }

    /*************************************************
     *          CLIPBOARD & SNIPPET MGMT
     *************************************************/
    function addClip(content, type) {
      const snippet = {
        content,
        type,
        timestamp: Date.now(),
        tags: [],
        favorite: false
      };
      clips.push(snippet);
      trackAction('add', snippet);
      saveClips();
      renderClips();
    }
    function renderClips(filter = "") {
      const panel = document.getElementById("clipboardPanel");
      const sorted = [
        ...clips.filter(c => c.favorite),
        ...clips.filter(c => !c.favorite)
      ];
      panel.innerHTML = sorted
        .filter(clip =>
          clip.content.toLowerCase().includes(filter.toLowerCase()) ||
          (clip.tags && clip.tags.some(t => t.toLowerCase().includes(filter.toLowerCase())))
        )
        .map(clip => {
          const index = clips.indexOf(clip);
          const color = varColorByType(clip.type);
          return `
          <div class="clip-item">
            <div class="type-indicator" style="background:${color}"></div>
            <div class="clip-content" title="${clip.content}" onclick="showClipPreview(${index})">
              ${clip.content}
              <div style="font-size:0.8em;color:#555;">
                ${new Date(clip.timestamp).toLocaleTimeString()}
                ${clip.tags.length ? '| Tags: ' + clip.tags.join(', ') : ''}
              </div>
            </div>
            <button onclick="copyToClipboard(${index})" data-tooltip="Copy"><i class="fas fa-copy"></i></button>
            <button onclick="toggleFavorite(${index})" style="background:${clip.favorite ? '#ffca28' : '#4caf50'}" data-tooltip="Favorite/Unfavorite">
              <i class="fas fa-star"></i>
            </button>
            <button onclick="editSnippet(${index})" style="background:#666;" data-tooltip="Edit"><i class="fas fa-pen"></i></button>
            <button onclick="deleteSnippet(${index})" style="background:#f44336;" data-tooltip="Delete"><i class="fas fa-trash"></i></button>
          </div>`;
        })
        .join("");
    }
    function varColorByType(type) {
      // You can customize color by type
      // For simplicity, green for recognized presets, purple for code, blue default
      if(type && regexPresets[type]) return "#4CAF50";
      if(type === 'code') return "#9C27B0";
      return "#2196f3";
    }
    function copyToClipboard(index) {
      if(!clips[index]) return;
      navigator.clipboard.writeText(clips[index].content).then(() => showNotification("Copied!"));
    }
    function copyAllClips() {
      if(!clips.length) {
        showNotification("No clips to copy.");
        return;
      }
      const allText = clips.map(c => c.content).join('\n');
      navigator.clipboard.writeText(allText).then(() => showNotification("All clips copied!"));
    }
    function toggleFavorite(index) {
      clips[index].favorite = !clips[index].favorite;
      saveClips();
      renderClips();
    }
    function editSnippet(index) {
      const oldContent = clips[index].content;
      const oldTags = [...clips[index].tags];
      const newContent = prompt("Edit snippet content:", oldContent);
      if(newContent !== null) {
        clips[index].content = newContent;
        const newTags = prompt("Update tags (comma-separated):", oldTags.join(", "));
        if(newTags !== null) {
          clips[index].tags = newTags.split(",").map(t => t.trim()).filter(Boolean);
        }
        trackAction('edit', { index, previousContent: oldContent, previousTags: oldTags });
        saveClips();
        renderClips();
      }
    }
    function deleteSnippet(index) {
      if(!confirm("Delete this snippet?")) return;
      const removedClip = clips[index];
      trackAction('delete', { index, clip: removedClip });
      clips.splice(index, 1);
      saveClips();
      renderClips();
    }
    function filterClips(query) {
      renderClips(query);
    }
    function showClipPreview(index) {
      alert("Preview:\n\n" + clips[index].content);
    }
    function clearAllClips() {
      if(!confirm("Are you sure you want to clear all snippets?")) return;
      clips = [];
      saveClips();
      renderClips();
    }

    /*************************************************
     *             IMPORT / EXPORT
     *************************************************/
    function exportClips() {
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(clips));
      const dlAnchor = document.createElement("a");
      dlAnchor.setAttribute("href", dataStr);
      dlAnchor.setAttribute("download", "clips.json");
      dlAnchor.click();
    }
    function importClips() {
      const fileInput = document.getElementById("fileInput");
      fileInput.value = "";
      fileInput.click();
      fileInput.addEventListener("change", function handleFile(e) {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
          try {
            const imported = JSON.parse(evt.target.result);
            if(Array.isArray(imported)) {
              clips = imported;
              saveClips();
              renderClips();
              alert("Clips imported!");
            } else {
              alert("Invalid file format.");
            }
          } catch(err) {
            alert("Failed to parse JSON.");
          }
        };
        reader.readAsText(file);
        fileInput.removeEventListener("change", handleFile);
      });
    }

    /*************************************************
     *        PRESET MANAGEMENT MODAL
     *************************************************/
    function openPresetSettings() {
      const container = document.getElementById('presetSettings');
      container.innerHTML = Object.entries(regexPresets).map(([id, p]) => `
        <div class="preset-item">
          <input type="checkbox" id="${id}" ${presetSettings[id] ? 'checked' : ''}>
          <label for="${id}">${p.name}</label>
          <i class="fas fa-info-circle" title="${p.desc}"></i>
        </div>
      `).join('');
      document.getElementById('presetSettingsModal').style.display = 'flex';
    }
    function savePresetSettings() {
      Object.entries(regexPresets).forEach(([id]) => {
        const checkbox = document.getElementById(id);
        presetSettings[id] = checkbox.checked;
      });
      localStorage.setItem('presetSettings', JSON.stringify(presetSettings));
      closePresetSettings();
      renderPresetCheckboxes(); // Rebuild the list of checkboxes for combined extraction
    }
    function closePresetSettings() {
      document.getElementById('presetSettingsModal').style.display = 'none';
    }

    /*************************************************
     *               THEME & UTILS
     *************************************************/
    function toggleTheme() {
      currentTheme = (currentTheme === "light") ? "dark" : "light";
      document.documentElement.setAttribute("data-theme", currentTheme);
      localStorage.setItem("theme", currentTheme);
    }
    function showNotification(msg) {
      const note = document.getElementById("notification");
      note.textContent = msg;
      note.style.display = "block";
      setTimeout(() => note.style.display = "none", 2000);
    }
    function toggleCollapse(sectionId) {
      document.getElementById(sectionId).classList.toggle("collapsed");
    }
    function saveClips() {
      localStorage.setItem("clips", JSON.stringify(clips));
    }

    /*************************************************
     *           HOTKEY HANDLING
     *************************************************/
    document.addEventListener("keydown", (e) => {
      // Ctrl+1..9 => copy snippet
      if(e.ctrlKey && e.key >= "1" && e.key <= "9") {
        e.preventDefault();
        const idx = parseInt(e.key) - 1;
        if(clips[idx]) copyToClipboard(idx);
      }
      // Ctrl+Z => Undo
      if(e.ctrlKey && e.key.toLowerCase() === "z") {
        e.preventDefault();
        undoLastAction();
      }
    });
  </script>
</body>
</html>
